
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Neuroimaging in Python &#8212; NiBabel 2.5.0dev documentation</title>
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="viewers" href="nibabel.viewers.html" />
    <link rel="prev" title="pydicom_compat" href="nibabel.pydicom_compat.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head><body>
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.viewers.html" title="viewers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.pydicom_compat.html" title="pydicom_compat"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" >API Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">API Reference</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">spaces</span></code></a><ul>
<li><a class="reference internal" href="#slice2volume">slice2volume</a></li>
<li><a class="reference internal" href="#vox2out-vox">vox2out_vox</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.pydicom_compat.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydicom_compat</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.viewers.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">viewers</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.spaces.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.spaces">
<span id="spaces"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">spaces</span></code><a class="headerlink" href="#module-nibabel.spaces" title="Permalink to this headline">¶</a></h1>
<p>Routines to work with spaces</p>
<p>A space is defined by coordinate axes.</p>
<p>A voxel space can be expressed by a shape implying an array, where the axes are
the axes of the array.</p>
<p>A mapped voxel space (mapped voxels) is either:</p>
<ul class="simple">
<li><p>an image, with attributes <code class="docutils literal notranslate"><span class="pre">shape</span></code> (the voxel space) and <code class="docutils literal notranslate"><span class="pre">affine</span></code> (the
mapping), or</p></li>
<li><p>a length 2 sequence with the same information (shape, affine).</p></li>
</ul>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.spaces.slice2volume" title="nibabel.spaces.slice2volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice2volume</span></code></a>(index, axis[, shape])</p></td>
<td><p>Affine expressing selection of a single slice from 3D volume</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#nibabel.spaces.vox2out_vox" title="nibabel.spaces.vox2out_vox"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vox2out_vox</span></code></a>(mapped_voxels[, voxel_sizes])</p></td>
<td><p>output-aligned shape, affine for input implied by <cite>mapped_voxels</cite></p></td>
</tr>
</tbody>
</table>
<div class="section" id="slice2volume">
<h2>slice2volume<a class="headerlink" href="#slice2volume" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.spaces.slice2volume">
<code class="descclassname">nibabel.spaces.</code><code class="descname">slice2volume</code><span class="sig-paren">(</span><em>index</em>, <em>axis</em>, <em>shape=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.spaces.slice2volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Affine expressing selection of a single slice from 3D volume</p>
<p>Imagine we have taken a slice from an image data array, <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">data[:,</span> <span class="pre">:,</span>
<span class="pre">index]</span></code>.  This function returns the affine to map the array coordinates of
<code class="docutils literal notranslate"><span class="pre">s</span></code> to the array coordinates of <code class="docutils literal notranslate"><span class="pre">data</span></code>.</p>
<p>This can be useful for resampling a single slice from a volume.  For
example, to resample slice <code class="docutils literal notranslate"><span class="pre">k</span></code> in the space of <code class="docutils literal notranslate"><span class="pre">img1</span></code> from the matching
spatial voxel values in <code class="docutils literal notranslate"><span class="pre">img2</span></code>, you might do something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">slice_shape</span> <span class="o">=</span> <span class="n">img1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span class="n">slice_aff</span> <span class="o">=</span> <span class="n">slice2volume</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">whole_aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">img2</span><span class="o">.</span><span class="n">affine</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">img1</span><span class="o">.</span><span class="n">affine</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">slice_aff</span><span class="p">))</span>
</pre></div>
</div>
<p>and then use <code class="docutils literal notranslate"><span class="pre">whole_aff</span></code> in <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.affine_transform</span></code>:</p>
<blockquote>
<div><p>rzs, trans = to_matvec(whole_aff)
data = img2.get_data()
new_slice = scipy.ndimage.affine_transform(data, rzs, trans, slice_shape)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>index of selected slice</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0, 1, 2}</span></dt><dd><p>axis to which <cite>index</cite> applies</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>slice_aff</strong><span class="classifier">shape (4, 3) affine</span></dt><dd><p>Affine relating input coordinates in a slice to output coordinates in
the embedded volume</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="vox2out-vox">
<h2>vox2out_vox<a class="headerlink" href="#vox2out-vox" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nibabel.spaces.vox2out_vox">
<code class="descclassname">nibabel.spaces.</code><code class="descname">vox2out_vox</code><span class="sig-paren">(</span><em>mapped_voxels</em>, <em>voxel_sizes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.spaces.vox2out_vox" title="Permalink to this definition">¶</a></dt>
<dd><p>output-aligned shape, affine for input implied by <cite>mapped_voxels</cite></p>
<p>The input (voxel) space, and the affine mapping to output space, are given
in <cite>mapped_voxels</cite>.</p>
<p>The output space is implied by the affine, we don’t need to know what that
is, we just return something with the same (implied) output space.</p>
<p>Our job is to work out another voxel space where the voxel array axes and
the output axes are aligned (top left 3 x 3 of affine is diagonal with all
positive entries) and which contains all the voxels of the implied input
image at their correct output space positions, once resampled into the
output voxel space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapped_voxels</strong><span class="classifier">object or length 2 sequence</span></dt><dd><p>If object, has attributes <code class="docutils literal notranslate"><span class="pre">shape</span></code> giving input voxel shape, and
<code class="docutils literal notranslate"><span class="pre">affine</span></code> giving mapping of input voxels to output space. If length 2
sequence, elements are (shape, affine) with same meaning as above. The
affine is a (4, 4) array-like.</p>
</dd>
<dt><strong>voxel_sizes</strong><span class="classifier">None or sequence</span></dt><dd><p>Gives the diagonal entries of <cite>output_affine</cite> (except the trailing 1
for the homogenous coordinates) (<code class="docutils literal notranslate"><span class="pre">output_affine</span> <span class="pre">==</span> <span class="pre">np.diag(voxel_sizes</span>
<span class="pre">+</span> <span class="pre">[1])</span></code>). If None, return identity <cite>output_affine</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output_shape</strong><span class="classifier">sequence</span></dt><dd><p>Shape of output image that has voxel axes aligned to original image
output space axes, and encloses all the voxel data from the original
image implied by input shape.</p>
</dd>
<dt><strong>output_affine</strong><span class="classifier">(4, 4) array</span></dt><dd><p>Affine of output image that has voxel axes aligned to the output axes
implied by input affine. Top-left 3 x 3 part of affine is diagonal with
all positive entries.  The entries come from <cite>voxel_sizes</cite> if
specified, or are all 1.  If the image is &lt; 3D, then the missing
dimensions will have a 1 in the matching diagonal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2019, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>