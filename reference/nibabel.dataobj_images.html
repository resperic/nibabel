
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Neuroimaging in Python &#8212; NiBabel 2.5.0dev documentation</title>
    <link rel="stylesheet" href="../_static/nibabel.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="deprecated" href="nibabel.deprecated.html" />
    <link rel="prev" title="cmdline" href="nibabel.cmdline.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience">

  </head><body>
<div style="background-color: white; text-align: left; padding-left: 150px; padding-bottom:50px; padding-top:20px; background-image: url(../_static/nipy-logo-bg-138x120.png); background-repeat: no-repeat;">
<h1>NiBabel</h1>
<h3 style="margin-top:-5px;color:#2f83c8">Access a cacophony of neuro-imaging file formats</h3>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nibabel.deprecated.html" title="deprecated"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nibabel.cmdline.html" title="cmdline"
             accesskey="P">previous</a> |</li>
  <li><a href="http://nipy.org/">Community</a> |&nbsp;</li>
  <li><a href="../index.html">NiBabel Home</a> |&nbsp;</li>
  <li><a href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing list</a> |&nbsp;</li>
  <li><a href="legal.html">License</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../api.html" >API Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">API Reference</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataobj_images</span></code></a><ul>
<li><a class="reference internal" href="#dataobjimage"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataobjImage</span></code></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nibabel.cmdline.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmdline</span></code></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="nibabel.deprecated.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">deprecated</span></code></a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/reference/nibabel.dataobj_images.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nibabel.dataobj_images">
<span id="dataobj-images"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">dataobj_images</span></code><a class="headerlink" href="#module-nibabel.dataobj_images" title="Permalink to this headline">¶</a></h1>
<p>File-based images that have data arrays</p>
<p>The class:<cite>DataObjImage</cite> class defines an image that extends the
<code class="xref py py-class docutils literal notranslate"><span class="pre">FileBasedImage</span></code> by adding an array-like object, named <code class="docutils literal notranslate"><span class="pre">dataobj</span></code>.
This can either be an actual numpy array, or an object that:</p>
<ul class="simple">
<li><p>returns an array from <code class="docutils literal notranslate"><span class="pre">numpy.asanyarray(obj)</span></code>;</p></li>
<li><p>has an attribute or property <code class="docutils literal notranslate"><span class="pre">shape</span></code>.</p></li>
</ul>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#nibabel.dataobj_images.DataobjImage" title="nibabel.dataobj_images.DataobjImage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataobjImage</span></code></a>(dataobj[, header, extra, file_map])</p></td>
<td><p>Template class for images that have dataobj data stores</p></td>
</tr>
</tbody>
</table>
<div class="section" id="dataobjimage">
<h2><a class="reference internal" href="#nibabel.dataobj_images.DataobjImage" title="nibabel.dataobj_images.DataobjImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataobjImage</span></code></a><a class="headerlink" href="#dataobjimage" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nibabel.dataobj_images.DataobjImage">
<em class="property">class </em><code class="descclassname">nibabel.dataobj_images.</code><code class="descname">DataobjImage</code><span class="sig-paren">(</span><em>dataobj</em>, <em>header=None</em>, <em>extra=None</em>, <em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nibabel.filebasedimages.html#nibabel.filebasedimages.FileBasedImage" title="nibabel.filebasedimages.FileBasedImage"><code class="xref py py-class docutils literal notranslate"><span class="pre">nibabel.filebasedimages.FileBasedImage</span></code></a></p>
<p>Template class for images that have dataobj data stores</p>
<p>Initialize dataobj image</p>
<p>The datobj image is a combination of (dataobj, header), with optional
metadata in <cite>extra</cite>, and filename / file-like objects contained in the
<cite>file_map</cite> mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataobj</strong><span class="classifier">object</span></dt><dd><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal notranslate"><span class="pre">np.asanyarray</span></code>.  It should have <code class="docutils literal notranslate"><span class="pre">shape</span></code> and <code class="docutils literal notranslate"><span class="pre">ndim</span></code>
attributes or properties</p>
</dd>
<dt><strong>header</strong><span class="classifier">None or mapping or header instance, optional</span></dt><dd><p>metadata for this image format</p>
</dd>
<dt><strong>extra</strong><span class="classifier">None or mapping, optional</span></dt><dd><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</dd>
<dt><strong>file_map</strong><span class="classifier">mapping, optional</span></dt><dd><p>mapping giving file information for this image format</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="nibabel.dataobj_images.DataobjImage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dataobj</em>, <em>header=None</em>, <em>extra=None</em>, <em>file_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize dataobj image</p>
<p>The datobj image is a combination of (dataobj, header), with optional
metadata in <cite>extra</cite>, and filename / file-like objects contained in the
<cite>file_map</cite> mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataobj</strong><span class="classifier">object</span></dt><dd><p>Object containg image data.  It should be some object that retuns an
array from <code class="docutils literal notranslate"><span class="pre">np.asanyarray</span></code>.  It should have <code class="docutils literal notranslate"><span class="pre">shape</span></code> and <code class="docutils literal notranslate"><span class="pre">ndim</span></code>
attributes or properties</p>
</dd>
<dt><strong>header</strong><span class="classifier">None or mapping or header instance, optional</span></dt><dd><p>metadata for this image format</p>
</dd>
<dt><strong>extra</strong><span class="classifier">None or mapping, optional</span></dt><dd><p>metadata to associate with image that cannot be stored in the
metadata of this image type</p>
</dd>
<dt><strong>file_map</strong><span class="classifier">mapping, optional</span></dt><dd><p>mapping giving file information for this image format</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.dataobj_images.DataobjImage.dataobj">
<code class="descname">dataobj</code><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.dataobj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="nibabel.dataobj_images.DataobjImage.from_file_map">
<em class="property">classmethod </em><code class="descname">from_file_map</code><span class="sig-paren">(</span><em>file_map</em>, <em>mmap=True</em>, <em>keep_file_open=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.from_file_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method to create image from mapping in <code class="docutils literal notranslate"><span class="pre">file_map</span></code></p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 2.4.1: </span><code class="docutils literal notranslate"><span class="pre">keep_file_open='auto'</span></code> is redundant with <cite>False</cite> and has
been deprecated. It will raise an error in nibabel 3.0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_map</strong><span class="classifier">dict</span></dt><dd><p>Mapping with (kay, value) pairs of (<code class="docutils literal notranslate"><span class="pre">file_type</span></code>, FileHolder
instance giving file-likes for each file needed for this image
type.</p>
</dd>
<dt><strong>mmap</strong><span class="classifier">{True, False, ‘c’, ‘r’}, optional, keyword only</span></dt><dd><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal notranslate"><span class="pre">memmap</span></code> for data array.
If one of {‘c’, ‘r’}, try numpy memmap with <code class="docutils literal notranslate"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal notranslate"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</dd>
<dt><strong>keep_file_open</strong><span class="classifier">{ None, True, False }, optional, keyword only</span></dt><dd><p><cite>keep_file_open</cite> controls whether a new file handle is created
every time the image is accessed, or a single file handle is
created and used for the lifetime of this <code class="docutils literal notranslate"><span class="pre">ArrayProxy</span></code>. If
<code class="docutils literal notranslate"><span class="pre">True</span></code>, a single file handle is created and used. If <code class="docutils literal notranslate"><span class="pre">False</span></code>,
a new file handle is created every time the image is accessed.
If <code class="docutils literal notranslate"><span class="pre">file_map</span></code> refers to an open file handle, this setting has no
effect. The default value (<code class="docutils literal notranslate"><span class="pre">None</span></code>) will result in the value of
<code class="docutils literal notranslate"><span class="pre">nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT</span></code> being used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>img</strong><span class="classifier">DataobjImage instance</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.dataobj_images.DataobjImage.from_filename">
<em class="property">classmethod </em><code class="descname">from_filename</code><span class="sig-paren">(</span><em>filename</em>, <em>mmap=True</em>, <em>keep_file_open=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.from_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method to create image from filename <cite>filename</cite></p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 2.4.1: </span><code class="docutils literal notranslate"><span class="pre">keep_file_open='auto'</span></code> is redundant with <cite>False</cite> and has
been deprecated. It will raise an error in nibabel 3.0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Filename of image to load</p>
</dd>
<dt><strong>mmap</strong><span class="classifier">{True, False, ‘c’, ‘r’}, optional, keyword only</span></dt><dd><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal notranslate"><span class="pre">memmap</span></code> for data array.
If one of {‘c’, ‘r’}, try numpy memmap with <code class="docutils literal notranslate"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal notranslate"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</dd>
<dt><strong>keep_file_open</strong><span class="classifier">{ None, True, False }, optional, keyword only</span></dt><dd><p><cite>keep_file_open</cite> controls whether a new file handle is created
every time the image is accessed, or a single file handle is
created and used for the lifetime of this <code class="docutils literal notranslate"><span class="pre">ArrayProxy</span></code>. If
<code class="docutils literal notranslate"><span class="pre">True</span></code>, a single file handle is created and used. If <code class="docutils literal notranslate"><span class="pre">False</span></code>,
a new file handle is created every time the image is accessed.
The default value (<code class="docutils literal notranslate"><span class="pre">None</span></code>) will result in the value of
<code class="docutils literal notranslate"><span class="pre">nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT</span></code> being used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>img</strong><span class="classifier">DataobjImage instance</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nibabel.dataobj_images.DataobjImage.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><em>caching='fill'</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return image data from image with any necessary scaling applied</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>We recommend you use the <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code> method instead of the
<code class="docutils literal notranslate"><span class="pre">get_data</span></code> method, because it is easier to predict the return
data type.  We will deprecate the <code class="docutils literal notranslate"><span class="pre">get_data</span></code> method around April
2018, and remove it around April 2020.</p>
<p>If you don’t care about the predictability of the return data type,
and you want the minimum possible data size in memory, you can
replicate the array that would be returned by <code class="docutils literal notranslate"><span class="pre">img.get_data()</span></code> by
using <code class="docutils literal notranslate"><span class="pre">np.asanyarray(img.dataobj)</span></code>.</p>
</div>
<p>The image <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> property can be an array proxy or an array.  An
array proxy is an object that knows how to load the image data from
disk.  An image with an array proxy <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> is a <em>proxy image</em>; an
image with an array in <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> is an <em>array image</em>.</p>
<p>The default behavior for <code class="docutils literal notranslate"><span class="pre">get_data()</span></code> on a proxy image is to read the
data from the proxy, and store in an internal cache.  Future calls to
<code class="docutils literal notranslate"><span class="pre">get_data</span></code> will return the cached array.  This is the behavior
selected with <cite>caching</cite> == “fill”.</p>
<p>Once the data has been cached and returned from an array proxy, if you
modify the returned array, you will also modify the cached array
(because they are the same array).  Regardless of the <cite>caching</cite> flag,
this is always true of an array image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>caching</strong><span class="classifier">{‘fill’, ‘unchanged’}, optional</span></dt><dd><p>See the Notes section for a detailed explanation.  This argument
specifies whether the image object should fill in an internal
cached reference to the returned image data array. “fill” specifies
that the image should fill an internal cached reference if
currently empty.  Future calls to <code class="docutils literal notranslate"><span class="pre">get_data</span></code> will return this
cached reference.  You might prefer “fill” to save the image object
from having to reload the array data from disk on each call to
<code class="docutils literal notranslate"><span class="pre">get_data</span></code>.  “unchanged” means that the image should not fill in
the internal cached reference if the cache is currently empty.  You
might prefer “unchanged” to “fill” if you want to make sure that
the call to <code class="docutils literal notranslate"><span class="pre">get_data</span></code> does not create an extra (cached)
reference to the returned array.  In this case it is easier for
Python to free the memory from the returned array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>array of image data</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nibabel.dataobj_images.DataobjImage.uncache" title="nibabel.dataobj_images.DataobjImage.uncache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">uncache</span></code></a></dt><dd><p>empty the array data cache</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>All images have a property <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> that represents the image array
data.  Images that have been loaded from files usually do not load the
array data from file immediately, in order to reduce image load time
and memory use.  For these images, <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> is an <em>array proxy</em>; an
object that knows how to load the image array data from file.</p>
<p>By default (<cite>caching</cite> == “fill”), when you call <code class="docutils literal notranslate"><span class="pre">get_data</span></code> on a
proxy image, we load the array data from disk, store (cache) an
internal reference to this array data, and return the array.  The next
time you call <code class="docutils literal notranslate"><span class="pre">get_data</span></code>, you will get the cached reference to the
array, so we don’t have to load the array data from disk again.</p>
<p>Array images have a <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> property that already refers to an
array in memory, so there is no benefit to caching, and the <cite>caching</cite>
keywords have no effect.</p>
<p>For proxy images, you may not want to fill the cache after reading the
data from disk because the cache will hold onto the array memory until
the image object is deleted, or you use the image <code class="docutils literal notranslate"><span class="pre">uncache</span></code> method.
If you don’t want to fill the cache, then always use
<code class="docutils literal notranslate"><span class="pre">get_data(caching='unchanged')</span></code>; in this case <code class="docutils literal notranslate"><span class="pre">get_data</span></code> will not
fill the cache (store the reference to the array) if the cache is empty
(no reference to the array).  If the cache is full, “unchanged” leaves
the cache full and returns the cached array reference.</p>
<p>The cache can affect the behavior of the image, because if the cache is
full, or you have an array image, then modifying the returned array
will modify the result of future calls to <code class="docutils literal notranslate"><span class="pre">get_data()</span></code>.  For example
you might do this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nibabel.testing</span> <span class="k">import</span> <span class="n">data_path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="s1">&#39;example4d.nii.gz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">img_fname</span><span class="p">)</span> <span class="c1"># This is a proxy image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nib</span><span class="o">.</span><span class="n">is_proxy</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dataobj</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The array is not yet cached by a call to “get_data”, so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">in_memory</span>
<span class="go">False</span>
</pre></div>
</div>
<p>After we call <code class="docutils literal notranslate"><span class="pre">get_data</span></code> using the default <cite>caching</cite> == ‘fill’, the
cache contains a reference to the returned array <code class="docutils literal notranslate"><span class="pre">data</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">in_memory</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We modify an element in the returned data array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
</pre></div>
</div>
<p>The next time we call ‘get_data’, the method returns the cached
reference to the (modified) array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span> <span class="ow">is</span> <span class="n">data</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
</pre></div>
</div>
<p>If you had <em>initially</em> used <cite>caching</cite> == ‘unchanged’ then the returned
<code class="docutils literal notranslate"><span class="pre">data</span></code> array would have been loaded from file, but not cached, and:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">img_fname</span><span class="p">)</span>  <span class="c1"># a proxy image again</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">caching</span><span class="o">=</span><span class="s1">&#39;unchanged&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">in_memory</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">caching</span><span class="o">=</span><span class="s1">&#39;unchanged&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span> <span class="ow">is</span> <span class="n">data</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.dataobj_images.DataobjImage.get_fdata">
<code class="descname">get_fdata</code><span class="sig-paren">(</span><em>caching='fill'</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.get_fdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Return floating point image data with necessary scaling applied</p>
<p>The image <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> property can be an array proxy or an array.  An
array proxy is an object that knows how to load the image data from
disk.  An image with an array proxy <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> is a <em>proxy image</em>; an
image with an array in <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> is an <em>array image</em>.</p>
<p>The default behavior for <code class="docutils literal notranslate"><span class="pre">get_fdata()</span></code> on a proxy image is to read
the data from the proxy, and store in an internal cache.  Future calls
to <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code> will return the cached array.  This is the behavior
selected with <cite>caching</cite> == “fill”.</p>
<p>Once the data has been cached and returned from an array proxy, if you
modify the returned array, you will also modify the cached array
(because they are the same array).  Regardless of the <cite>caching</cite> flag,
this is always true of an array image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>caching</strong><span class="classifier">{‘fill’, ‘unchanged’}, optional</span></dt><dd><p>See the Notes section for a detailed explanation.  This argument
specifies whether the image object should fill in an internal
cached reference to the returned image data array. “fill” specifies
that the image should fill an internal cached reference if
currently empty.  Future calls to <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code> will return this
cached reference.  You might prefer “fill” to save the image object
from having to reload the array data from disk on each call to
<code class="docutils literal notranslate"><span class="pre">get_fdata</span></code>.  “unchanged” means that the image should not fill in
the internal cached reference if the cache is currently empty.  You
might prefer “unchanged” to “fill” if you want to make sure that
the call to <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code> does not create an extra (cached)
reference to the returned array.  In this case it is easier for
Python to free the memory from the returned array.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy dtype specifier</span></dt><dd><p>A numpy dtype specifier specifying a floating point type.  Data is
returned as this floating point type.  Default is <code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fdata</strong><span class="classifier">array</span></dt><dd><p>Array of image data of data type <cite>dtype</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#nibabel.dataobj_images.DataobjImage.uncache" title="nibabel.dataobj_images.DataobjImage.uncache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">uncache</span></code></a></dt><dd><p>empty the array data cache</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>All images have a property <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> that represents the image array
data.  Images that have been loaded from files usually do not load the
array data from file immediately, in order to reduce image load time
and memory use.  For these images, <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> is an <em>array proxy</em>; an
object that knows how to load the image array data from file.</p>
<p>By default (<cite>caching</cite> == “fill”), when you call <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code> on a
proxy image, we load the array data from disk, store (cache) an
internal reference to this array data, and return the array.  The next
time you call <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code>, you will get the cached reference to the
array, so we don’t have to load the array data from disk again.</p>
<p>Array images have a <code class="docutils literal notranslate"><span class="pre">dataobj</span></code> property that already refers to an
array in memory, so there is no benefit to caching, and the <cite>caching</cite>
keywords have no effect.</p>
<p>For proxy images, you may not want to fill the cache after reading the
data from disk because the cache will hold onto the array memory until
the image object is deleted, or you use the image <code class="docutils literal notranslate"><span class="pre">uncache</span></code> method.
If you don’t want to fill the cache, then always use
<code class="docutils literal notranslate"><span class="pre">get_fdata(caching='unchanged')</span></code>; in this case <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code> will not
fill the cache (store the reference to the array) if the cache is empty
(no reference to the array).  If the cache is full, “unchanged” leaves
the cache full and returns the cached array reference.</p>
<p>The cache can effect the behavior of the image, because if the cache is
full, or you have an array image, then modifying the returned array
will modify the result of future calls to <code class="docutils literal notranslate"><span class="pre">get_fdata()</span></code>.  For example
you might do this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nibabel.testing</span> <span class="k">import</span> <span class="n">data_path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="s1">&#39;example4d.nii.gz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">img_fname</span><span class="p">)</span> <span class="c1"># This is a proxy image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nib</span><span class="o">.</span><span class="n">is_proxy</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dataobj</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The array is not yet cached by a call to “get_fdata”, so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">in_memory</span>
<span class="go">False</span>
</pre></div>
</div>
<p>After we call <code class="docutils literal notranslate"><span class="pre">get_fdata</span></code> using the default <cite>caching</cite> == ‘fill’, the
cache contains a reference to the returned array <code class="docutils literal notranslate"><span class="pre">data</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">in_memory</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We modify an element in the returned data array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">99.0</span>
</pre></div>
</div>
<p>The next time we call ‘get_fdata’, the method returns the cached
reference to the (modified) array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span> <span class="ow">is</span> <span class="n">data</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">99.0</span>
</pre></div>
</div>
<p>If you had <em>initially</em> used <cite>caching</cite> == ‘unchanged’ then the returned
<code class="docutils literal notranslate"><span class="pre">data</span></code> array would have been loaded from file, but not cached, and:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">img_fname</span><span class="p">)</span>  <span class="c1"># a proxy image again</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">(</span><span class="n">caching</span><span class="o">=</span><span class="s1">&#39;unchanged&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">in_memory</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">(</span><span class="n">caching</span><span class="o">=</span><span class="s1">&#39;unchanged&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span> <span class="ow">is</span> <span class="n">data</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_again</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nibabel.dataobj_images.DataobjImage.get_shape">
<code class="descname">get_shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.get_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return shape for image</p>
<p>get_shape method is deprecated.
Please use the <code class="docutils literal notranslate"><span class="pre">img.shape</span></code> property instead.</p>
<ul class="simple">
<li><p>deprecated from version: 1.2</p></li>
<li><p>Will raise &lt;class ‘nibabel.deprecator.ExpiredDeprecationError’&gt; as of version: 3.0</p></li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.dataobj_images.DataobjImage.in_memory">
<code class="descname">in_memory</code><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.in_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>True when any array data is in memory cache</p>
<p>There are separate caches for <cite>get_data</cite> reads and <cite>get_fdata</cite> reads.
This property is True if either of those caches are set.</p>
</dd></dl>

<dl class="classmethod">
<dt id="nibabel.dataobj_images.DataobjImage.load">
<em class="property">classmethod </em><code class="descname">load</code><span class="sig-paren">(</span><em>filename</em>, <em>mmap=True</em>, <em>keep_file_open=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Class method to create image from filename <cite>filename</cite></p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 2.4.1: </span><code class="docutils literal notranslate"><span class="pre">keep_file_open='auto'</span></code> is redundant with <cite>False</cite> and has
been deprecated. It will raise an error in nibabel 3.0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str</span></dt><dd><p>Filename of image to load</p>
</dd>
<dt><strong>mmap</strong><span class="classifier">{True, False, ‘c’, ‘r’}, optional, keyword only</span></dt><dd><p><cite>mmap</cite> controls the use of numpy memory mapping for reading image
array data.  If False, do not try numpy <code class="docutils literal notranslate"><span class="pre">memmap</span></code> for data array.
If one of {‘c’, ‘r’}, try numpy memmap with <code class="docutils literal notranslate"><span class="pre">mode=mmap</span></code>.  A
<cite>mmap</cite> value of True gives the same behavior as <code class="docutils literal notranslate"><span class="pre">mmap='c'</span></code>.  If
image data file cannot be memory-mapped, ignore <cite>mmap</cite> value and
read array from file.</p>
</dd>
<dt><strong>keep_file_open</strong><span class="classifier">{ None, True, False }, optional, keyword only</span></dt><dd><p><cite>keep_file_open</cite> controls whether a new file handle is created
every time the image is accessed, or a single file handle is
created and used for the lifetime of this <code class="docutils literal notranslate"><span class="pre">ArrayProxy</span></code>. If
<code class="docutils literal notranslate"><span class="pre">True</span></code>, a single file handle is created and used. If <code class="docutils literal notranslate"><span class="pre">False</span></code>,
a new file handle is created every time the image is accessed.
The default value (<code class="docutils literal notranslate"><span class="pre">None</span></code>) will result in the value of
<code class="docutils literal notranslate"><span class="pre">nibabel.arrayproxy.KEEP_FILE_OPEN_DEFAULT</span></code> being used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>img</strong><span class="classifier">DataobjImage instance</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nibabel.dataobj_images.DataobjImage.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.ndim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nibabel.dataobj_images.DataobjImage.shape">
<code class="descname">shape</code><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nibabel.dataobj_images.DataobjImage.uncache">
<code class="descname">uncache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nibabel.dataobj_images.DataobjImage.uncache" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete any cached read of data from proxied data</p>
<p>Remember there are two types of images:</p>
<ul class="simple">
<li><p><em>array images</em> where the data <code class="docutils literal notranslate"><span class="pre">img.dataobj</span></code> is an array</p></li>
<li><p><em>proxy images</em> where the data <code class="docutils literal notranslate"><span class="pre">img.dataobj</span></code> is a proxy object</p></li>
</ul>
<p>If you call <code class="docutils literal notranslate"><span class="pre">img.get_fdata()</span></code> on a proxy image, the result of reading
from the proxy gets cached inside the image object, and this cache is
what gets returned from the next call to <code class="docutils literal notranslate"><span class="pre">img.get_fdata()</span></code>.  If you
modify the returned data, as in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span>
<span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div>
</div>
<p>then the next call to <code class="docutils literal notranslate"><span class="pre">img.get_fdata()</span></code> returns the modified array,
whether the image is an array image or a proxy image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">()</span> <span class="o">==</span> <span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>When you uncache an array image, this has no effect on the return of
<code class="docutils literal notranslate"><span class="pre">img.get_fdata()</span></code>, but when you uncache a proxy image, the result of
<code class="docutils literal notranslate"><span class="pre">img.get_fdata()</span></code> returns to its original value.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2019, Chris Markiewicz &lt;neuroimaging@python.org&gt;.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>